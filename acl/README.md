# acl
[GitHub 저장소](https://github.com/acl-dev/acl )에 있는 문서를 기계 번역 및 정리한 것이다  
  
## 프로젝트 소개 
Acl(고급 C/C++ 라이브러리) 프로젝트는 강력한 멀티 플랫폼 네트워크 통신 라이브러리 및 서비스 프레임워크로, Linux, WIN32, Solaris, FreeBSD, MacOS, AndroidOS, iOS를 지원한다.   
Acl로 작성된 많은 애플리케이션은 Linux, Windows, iPhone 및 Android가 설치된 여러 기기에서 실행되며 수십억 명의 사용자에게 서비스를 제공한다.   
Acl 프로젝트에는 네트워크 통신, 서버 프레임워크, 애플리케이션 프로토콜, 다중 코더 등 몇 가지 중요한 모듈이 있다.  
HTTP/SMTP/ICMP//MQTT/Redis/Memcached/Beanstalk/Handler Socket 과 같은 일반적인 프로토콜이 Acl에서 구현되며, XML/JSON/MIME/BASE64/UUCODE/QPCODE/RFC2047/RFC1035 등과 같은 코덱 라이브러리도 Acl에 포함되어 있다. 또한 Acl은 Mysql, Postgresql, Sqlite와 같이 널리 사용되는 데이터베이스를 위한 통합 추상 인터페이스도 제공한다.  
**Acl 라이브러리를 사용하면 데이터베이스 애플리케이션을 더 쉽고, 빠르고, 안전하게 작성할 수 있다**.    


## 1. 가장 중요한 6가지 모듈
C/C++ 기반 라이브러리인 Acl은 사용자가 애플리케이션을 개발하는데 유용한 여러 기능을 제공하며, 여기에는 6가지 중요한 모듈이 포함되어 있다:  
네트워크, 코루틴, HTTP, Redis 클라이언트, MQTT, 서버 프레임워크이다.  
  
### 1.1. 기본 네트워크 모듈
- 스트림 처리 모듈 전체 acl 네트워크 통신을 위한 가장 기본적인 스트리밍 통신 모듈이다. 네트워크 스트리밍을 지원할 뿐만 아니라 파일 스트리밍도 지원한다.   
    - 한 줄씩 데이터를 읽고, win32에서는 \r\n과 호환되며, UNIX에서는 \n의 끝과 호환됩니다.
	- 데이터를 한 줄씩 읽되 후행 \n 또는 \r\n을 자동으로 제거해야 한다.
	- 문자열 구분 기호로 데이터 읽기
	- 지정된 길이의 데이터 읽기
	- 데이터 행을 읽거나 지정된 길이의 데이터를 읽으려고 시도한다.
	- 네트워크 IO 상태 감지
	- 데이터 행 쓰기
	- 포맷터로 데이터 쓰기(fprintf와 유사)
	- 파일 스트림 위치 작업, fseek과 유사함
	- 유닉스에서 writev와 유사하게 데이터 집합을 한 번에 쓴다.
	- f트렁크와 유사하게 파일 잘라내기
	- 파일 크기 가져오기
	- ftell과 유사하게 현재 파일 스트림 포인터 위치를 가져온다.
	- 파일 크기 가져오기
	- 네트워크 스트림의 로컬 주소 및 원격 주소 가져오기
- 네트워크 운영 모듈
    - 이 모듈은 주로 네트워크 서버 모니터링(TCP/UDP/UNIX 도메인 소켓 지원), 네트워크 클라이언트 연결(TCP/UNIX 도메인 소켓 지원), DNS 도메인 이름 쿼리 및 결과 캐시(호출 시스템 gethostbyname/getaddrinfo 기능 및 직접 보내기 DNS 프로토콜 두 가지 방법 지원), 소켓(소켓) 작업 및 로컬 네트워크 카드 및 기타 기능을 지원한다.
- 비차단 네트워크 흐름
    - 비차단 모드 연결, 읽기(행별 읽기, 지정된 길이 읽기), 쓰기(줄 쓰기, 지정된 길이 쓰기, 데이터 세트 쓰기) 및 기타 작업을 지원한다.
- 공통 네트워크 애플리케이션 프로토콜 라이브러리
    - 주로 다음과 같은 일반적인 네트워크 애플리케이션 프로토콜을 지원한다: HTTP, SMTP, ICMP를 지원하며, HTTP와 ICMP 모듈은 차단 및 비차단 통신 방법을 구현한다. 또한 HTTP 프로토콜은 C++ 버전의 lib_acl_cpp에서 서버와 클라이언트를 지원한다. 두 가지 통신 방식은 서버로 사용할 경우 JAVA HttpServlet과 유사한 인터페이스 사용을 지원한다. 클라이언트 모드로 사용할 경우 연결 풀과 클러스터 관리를 지원한다. 이 모듈은 쿠키, 세션, HTTP MIME 파일 업로드를 모두 지원한다. 블록 전송, 자동 문자 세트 변환, 자동 압축 해제, 중단점 재개와 같은 다양한 기능을 제공한다.
- 공통 네트워크 통신 라이브러리
    - 멤캐시드, beanstalk, 핸들러 소켓 클라이언트 통신 라이브러리를 지원하며, 통신 라이브러리는 연결 풀 모드를 지원한다.
  
### 1.2. 코루틴
Acl의 코루틴 모듈은 여러 플랫폼에서 사용할 수 있으며, 일부 중요한 프로젝트에는 많은 엔지니어링 관행이 있다.  
- Linux, MacOS, Windows, iOS 및 Android에서 실행
- x86, Arm 아키텍처 지원
- select/poll/epoll/kqueue/iocp/win32 GUI 메시지 지원
- DNS 프로토콜은 acl 코루틴으로 구현되었으므로 코루틴 모델에서도 DNS API를 사용할 수 있다.
- Unix 및 Windows의 Hook 시스템 IO API
    - 읽기 API: read/readv/recv/recvfrom/recvmsg
	- 쓰기 API: write/writev/send/sendto/sendmsg/sendfile64
	- 소켓 API: 소켓/듣기/수락/연결/셋소켓옵트
	- 이벤트 API: select/poll/epoll_create/epoll_ctl/epoll_wait
	- DNS API: gethostbyname/gethostbyname_r/getaddrinfo/freeaddrinfo
- 메모리 사용량을 최소화하는 공유 스택 모드 지원
- 동기화 프리미티브
    - 코루틴 뮤텍스, 셈포어는 코루틴 간에 사용할 수 있다.
	- 코루틴 이벤트는 코루틴과 스레드 간에 사용할 수 있다.
- 자세한 내용은 Acl 파이버 사용을 참조하세요.
  

### 1.3. HTTP 모듈
HTTP/1.1을 지원하며 클라이언트 및 서버 측에서 사용할 수 있다.
- Java(서버 측)와 같은 HttpServlet 인터페이스
- 연결 풀 모드(클라이언트 측)
- 청크 블록 전송
- Gzip 압축/압축 해제
- SSL 암호화
- 중단점 전송
- 쿠키 설정/취득
- 세션 관리(서버 측)
- 웹소켓 전송
- HTTP MIME 형식
- 동기화/비동기화 모드
  

### 1.4. Redis 클라이언트
Acl의 redis 클라이언트 모듈은 강력하고 고성능이며 사용하기 쉽다.  
- 비트맵/스트링/해시/리스트/셋/소트셋/펍서브/하이퍼로그/지오/스크립트/스트림/서버/클러스터 등을 지원한다.
- 각 redis 명령에 대해 stl과 유사한 C++ 인터페이스 제공
- 클라이언트에서 redis 클러스터의 해시 슬롯 변경을 자동으로 캐싱하고 적용한다.
- 단일, 클러스터 또는 파이프라인 모드에서의 통신
- 시그널 또는 클러스터 모드에서 연결 풀 사용
- 클러스터 또는 파이프라인 모드에서 고성능
- 단일, 클러스터 및 파이프라인 모드에 동일한 인터페이스 제공
- 네트워크 오류로 인해 자동으로 재시도
- 공유 스택 코루틴 모드에서 사용 가능
- 자세한 내용은 [Acl redis 클라이언트 사용](https://github.com/acl-dev/acl/blob/master/lib_acl_cpp/samples/redis/README.md )을 참조하시오.  
  

### 1.5. MQTT 모듈
MQTT 3.1.1 버전은 스트림 파서가 있는 Acl에서 구현되었기 때문에 어떤 IO 모드와도 독립적으로 사용할 수 있다.
- MQTT 3.1. 1 프로토콜을 지원한다: connect/connack/게시/게시백/게시레크/게시레크/게시컴프/구독/구독백/구독해제/구독해제/핑요청/핑응답/연결해제
- 명령당 하나의 클래스
- 스트림 파서는 모든 IO 모드에 사용할 수 있다.
- 네트워크 통신과 분리된 데이터 구문 분석
- 클라이언트 및 서버 측에서 사용 가능
- 자세한 내용은 [Acl MQTT 사용](https://github.com/acl-dev/acl/blob/master/lib_acl_cpp/samples/mqtt/README.md )을 참조하시오.
  

### 1.6. 서버 프레임워크
Acl에서 가장 중요한 모듈은 서버 프레임워크로 사용자가 웹 서비스와 같은 백엔드 서비스를 빠르게 작성할 수 있도록 도와준다. 앱/마법사의 도구를 사용하면 몇 초 안에 적절한 서비스 코드를 생성할 수 있다. Acl의 서버 프레임워크는 두 부분으로 구성되어 있는데 하나는 서비스 매니저이고 다른 하나는 Acl 서비스 템플릿으로 작성된 서비스이다. Acl에서 acl_master라는 이름의 서비스 관리자는 마스터라는 유명한 MTA 포스트픽스에서 유래했으며, acl_master는 하나의 일반 서비스 관리자가 되기 위해 마스터에 대한 많은 확장을 가지고 있다. Acl에는 아래와 같이 애플리케이션 서비스를 작성하는 데 사용할 수 있는 6개의 서비스 템플릿이 있다: 
- 프로세스 서비스: 하나의 연결 하나의 프로세스로, 프로그래밍이 간단하고 안전하며 안정적이라는 장점이 있지만 동시성이 너무 낮다는 단점이 있다
- 스레드 서비스: 각 프로세스는 스레드 풀의 스레드 집합을 통해 모든 클라이언트 연결을 처리한다. 읽기 가능한 데이터가 있는 경우에만 연결이 스레드에 바인딩 되고, 데이터를 처리한 후 스레드가 해제되는 IO 이벤트 트리거 모드가 사용된다. 이 서비스 모델의 장점은 적은 수의 스레드로 하나의 프로세스에서 많은 수의 클라이언트 연결을 처리할 수 있다는 것이다. aio 모델에 비해 프로그래밍이 비교적 간단하다
- Aio 서비스: nginx/squid/ircd 와 유사하게, 하나의 스레드가 비차단(논블럭킹) IO 방식으로 많은 수의 클라이언트 연결을 처리할 수 있다. 이 모델의 장점은 높은 처리 효율과 낮은 리소스 소비이지만, 단점은 프로그래밍이 더 복잡하다는 것이다
- 코루틴 서비스: 비차단 서비스 모델은 대규모 동시 처리 능력을 얻을 수 있지만 프로그래밍 복잡성이 높다. 코루틴 모델은 대규모 동시 처리와 낮은 프로그래밍 복잡성의 특징을 결합하여 프로그래머가 순차적 IO 프로그래밍을 쉽게 구현할 수 있도록 지원한다
- UDP 서비스: 이 모델은 주로 UDP 통신 프로세스를 지원하는 서비스 모델이다
- 트리거 서비스: 모델 인스턴스는 주로 예약된 일부 작업의 백그라운드 서비스 프로세스를 처리하는 데 사용된다(시스템의 크론탭과 유사).
  

## 2. 기타 중요한 모듈
  
### 2.1. MIME 모듈
MIME(Multipurpose Internet Mail Extensions) 형식은 이메일 애플리케이션에서 널리 사용된다. MIME 형식은 이메일 애플리케이션뿐만 아니라 웹 애플리케이션에서도 사용할 수 있을 정도로 매우 중요하다. RFC2045/RFC2047/RFC822와 같은 MIME RFC가 Acl에 구현되어 있다. Acl은 IO 모델에 독립적인 MIME 데이터 스트림 파서를 가지고 있어서 동기 또는 비동기 IO 프로그램에서 사용할 수 있다.  
    
### 2.2. 코덱 모듈
Acl에는 Json, Xml, Base64, Url 등과 같은 몇 가지 일반적인 코덱이 있는데, 이들은 모두 스트림 파서이며 IO 통신과 무관하다. Json은 매우 널리 사용되므로 Acl은 직렬화/역직렬화 도구도 제공하여 Json 데이터와 C 구조체 객체 간 전송에 사용할 수 있으므로 프로그래밍 효율성이 크게 향상된다.  
    
### 2.3. 데이터베이스 모듈
Acl의 통합 데이터베이스 인터페이스는 Mysql, Postgresql 및 SQLite와 같은 잘 알려진 오픈 소스 데이터베이스를 쉽고 안전하게 작동하도록 설계되었다. SQL 코덱은 DB SQL 공격을 피하기 위해 문자를 이스케이프 처리하도록 설계되었다. 사용자가 Acl을 사용하여 데이터베이스 애플리케이션을 작성할 때 Acl은 Mysql, Postgresql 또는 SQLite의 동적 라이브러리를 동적으로 로드한다. 동적 로딩의 장점은 데이터베이스 기능이 필요하지 않은 사용자는 전혀 신경 쓰지 않아도 된다는 것이다.  
    
### 2.4. 연결 풀 관리자
Acl에는 일반 연결 풀 관리자가 있는데, 이 관리자는 redis, 데이터베이스, http 모듈 등 다른 중요한 모듈에서 널리 사용된다.  
    
### 2.5. 기타 클라이언트 라이브러리
redis 클라이언트 외에도 Acl은 멤캐시드 클라이언트, 핸들러 소켓, 빈스토크, 디스크 등과 같은 다른 중요한 클라이언트 라이브러리도 구현한다.  
    
### 2.6. DNS 모듈
Acl은 getaddrinfo 및 gethostbyname과 같은 시스템 DNS API를 래핑할 뿐만 아니라 RFC1035에 지정된 DNS 프로토콜도 구현한다. 사용자는 Acl의 DNS 모듈을 사용하여 자체 DNS 클라이언트 또는 서버를 구현할 수 있다.
    
  
## 3. 플랫폼 지원 및 컴파일
  
### 3.1. 다른 플랫폼에서 Acl 컴파일하기
Acl 프로젝트는 현재 리눅스, 윈도우, 맥OS, 프리BSD, 솔라리스, 안드로이드, iOS를 지원한다.  
- 리눅스/유닉스: 컴파일러는 gcc/clang 이고, acl/ 디렉터리에 들어가 make를 실행하면 acl/ 디렉터리에 libacl_all.a와 libacl_all.so가 생성되며, libacl_all.a는 lib_acl.a, lib_protocol.a, libacl_cpp.a 등 3개의 라이브러리로 구성된다
- Windows: VS2003/VS2008/VS2010/VS2012/VS2013/VS2015/VS2019로 컴파일할 수 있다. (VS6/VS2005로 컴파일해야 하는 경우, VS2003의 컴파일 조건을 참조한다)
- MacOS/iOS: xcode로 컴파일
- 안드로이드: 안드로이드 스튜디오에서 acl/android/acl_c++_shared/ 에서 애드노이드의 프로젝트를 연다
- cmake로 크로스 플랫폼 컴파일을 지원한다.
  
### 3.2. Windows에서 컴파일할 때 주의 사항
WIN32 환경에서 동적 라이브러리를 사용할 때 몇 가지 유의해야 할 사항이 있다:
- 동적 라이브러리 lib_acl을 사용할 때는 사용자 프로젝트에서 미리 정의해야 한다: ACL_DLL
- lib_protocol 동적 라이브러리에서 HTTP 라이브러리 또는 ICMP 라이브러리를 사용하는 경우 프로젝트에서 HTTP_DLL 또는 ICMP_DLL을 미리 정의해야 한다
- lib_acl_cpp의 동적 라이브러리를 사용하는 경우, 프로젝트에서 ACL_CPP_DLL을 미리 정의해야 한다. VC2003 컴파일러 환경을 사용하는 경우 VC2003을 미리 정의해야 한다.
- 동적 라이브러리인 lib_dict 를 사용하는 경우 프로젝트에서 DICT_DLL 을 미리 정의해야 한다
- 동적 라이브러리 lib_tls를 사용하는 경우 프로젝트에서 TLS_DLL을 미리 정의해야 한다.
- 자세한 컴파일 과정은 다음을 참조하세요: [acl 라이브러리 컴파일 및 사용](https://github.com/acl-dev/acl/blob/master/BUILD.md )
  
  
   













